## 1. 下标引用、函数调用和结构成员

```c
int arr[10] = {1, 2, 3};
printf("%d\n", arr[1]);
```

`[]` 为下标引用操作符，操作数有两个，分别是arr和1；

`()` 为函数调用操作符，操作数为函数名和函数参数；

`.` 、`->` 为结构成员操作符：

结构体成员的两种访问方式：

1. 结构体变量.成员

2. 结构体指针->成员

## 2. 表达式求值

表达式求值的顺序一部分是由操作符的优先级和结合性决定。

同样，有些表达式的操作数在求值过程中可能需要转换为其他类型。

### 隐式类型转换

C的整形算术运算总是至少以缺省整形类型的精度来进行的。

为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整形，这种转换称为**整形提升**

举个例子：

```c
char a, b, c;
...
a = b + c;
```

b和c的值被提升为普通整形，然后再执行加法运算。

加法运算完成之后，得到的结果是4个字节大小的，会被截断，然后再存储于 `a` 中。

**举个实际的例子1：**

```c
char a = 3;        // a: 00000011
char b = 127;      // b: 01111111
char c = a + b;
printf("c = %d\n", c);
```

> c = -126

计算过程如下：

```c
// 先进行整形提升    
//    a: 00000000000000000000000000000011
//    b: 00000000000000000000000001111111
//  a+b: 00000000000000000000000010000010
//    c: 10000010 (补码)
// 因为要打印的c也是整形(%d)的, 所以对c也会进行整形提升，提升为：
//    c: 11111111111111111111111110000010 (补码)
//    c: 11111111111111111111111110000001 (反码)
//    c: 10000000000000000000000001111110 (原码: -126) 
```

**举个实际的例子2**：10-127= -117 (无溢出)

```c
// -127: 10000000000000000000000001111111 (原码)
// -127: 11111111111111111111111110000000 (反码)
// -127: 11111111111111111111111110000001 (补码)
// 10:   00000000000000000000000000001010
// sum:  11111111111111111111111110001011 (和)
// sum:  10001011 (截断)
// sum:  11111111111111111111111110001011 (提升，补码)
// sum:  11111111111111111111111110001010 (提升，反码)
// sum:  10000000000000000000000001110101 (提升，原码)
// sum:  -(2^6+2^5+2^4+2^2+1) = -(64+32+16+4+1) = -117
```

## 3. 补码和原码互相转换，都可以按取反加1来转

例如：

**-1的原码转换为补码过程如下**

-1原码：10000000000000000000000000000001

   取反：11111111111111111111111111111110

-1补码：11111111111111111111111111111111

**-1的补码转换为原码过程如下**

-1补码：11111111111111111111111111111111

  取反： 10000000000000000000000000000000

-1原码：10000000000000000000000000000001
