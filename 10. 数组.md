# 一维数组

## 1. 一维数组的创建和初始化

数组是一组相同类型元素的集合，数组的创建方式如下：

> type_t  arr_name [const_n];    // const_n 是一个常量表达式，用来指定数组的大小

数组的初始化：

```c
int arr[10] = {1, 3, 5, 6, 4};  // 不完全初始化，未被初始化的元素默认为0
int arr2[10] = {1, 3, 5, 6, 4, 6, 5, 6, 2, 1};  //完全初始化
```

注意，在下面的语句中，尽管a1， a2初始化的结果是一样的，但是a1表达的是有3个元素未被初识化，最后三个元素都是0；a2表达的是有两个元素未被初始化，被初始化的前三个元素分别是'a','b','\0'  (注：'\0'的值是0)

```c
char a1[5] = {'a', 'b'}; // 等效于 char a1[5] = {'a', 98};
char a2[5] = "ab"; // 最好使用这种方式
```

当没有指定数组大小时，必须对数组进行初始化：

```c
char a3[] = "abcdf";
```

### test: 请问以下代码的输出是什么？

```c
char a1[] = {'a', 'b'};
char a2[] = "ab";
printf("a1's size is %d\n", sizeof(a1));
printf("a2's size is %d\n", sizeof(a2));
printf("a1's length is %d\n", strlen(a1));  // 不同的编译器结果可能不一样，可能是随机值
printf("a2's length is %d\n", strlen(a2));
```

>a1's size is 2
>a2's size is 3
>a1's length is 3
>a2's length is 2

strlen是库函数，sizeof是操作符；

## 2. 一维数组的使用

下标引用操作符：[]  , 它其实就是数组访问的操作符。

## 3. 一维数组在内存中的存储

数组在内存中是连续存储的

运行如下程序：

```c
int arr[8] = {1, 2, 3};
int sz = sizeof(arr)/sizeof(arr[0]);
for (int i=0; i<sz; i++)
{
    printf("&arr[%d]=%p\n", i, &arr[i]);
}
```

得到结果：

>&arr[0]=0x16fdff460
>&arr[1]=0x16fdff464
>&arr[2]=0x16fdff468
>&arr[3]=0x16fdff46c
>&arr[4]=0x16fdff470
>&arr[5]=0x16fdff474
>&arr[6]=0x16fdff478
>&arr[7]=0x16fdff47c

# 二维数组

## 1. 二维数组的创建和初始化

以下初始化方法是✅的：

``` c
int arr1[3][4] = {1, 2, 3, 4, 5};
int arr2[3][4] = {{1, 2, 3}, 4, 5};
int arr3[3][4] = {{1, 2, 3}, {4}, 5};
int arr4[3][4] = {{1, 2, 3, 4},{5, 6, 7, 8}};
int arr5[][4] = {{1, 2, 3, 4},{5, 6, 7, 8}};
```

错误的初始化方法1： `int arr[][] = {1, 3, 4};` ❌

错误的初始化方法2： `int arr[][] = {{1, 3, 4}, {4, 5, 7};` ❌

错误的初始化方法3：`int arr5[3][] = {{1, 2, 3, 4},{5, 6, 7, 8}};`  ❌列数不能省略

## 2. 二维数组的使用

```c
int arr3[3][4] = {{1, 2, 3}, {4, 5}, 5};
for (int i = 0; i < 3; i++)
{
    for (int j = 0; j < 4; j++)
    {
        printf("%d ", arr3[i][j]);
    }
    printf("\n");
}
```

## 3. 二维数组在内存中的存储

像一维数组一样，二维数组在内存中也是连续存储的

