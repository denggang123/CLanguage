## 1. 指针初识

因为地址是指向内存单元的，所以也形象地**把地址形地称为指针**

在同一平台中，指针所占的内存空间都是一样的：在32位平台上都是4个字节，在64位平台上是8个字节；

但是这并不意味着指针类型没意义，因为**指针类型决定了**：

1. 指针解引用的权限有多大；
2. 指针走一步，能走多远；

**想一想：** 为什么void类型的指针不能进行解引用操作，也不能加一减一？

## 2. 野指针

> 概念：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）

野指针成因：

1. 指针未初始化；

   ```c
   int* p;
   *p = 20;  /* 非法访问内存 */
   ```

2. 指针越界访问

   ```c
   int arr[10] = {0};
   int * p = arr;
   for (int i=0; i<=10; i++)
   {
       *p = 1;
       p++;
   }
   ```

3. 指针变量指向的内存空间释放，还给操作系统了，但指针变量还存储了原来指向的地址

   ```c
   int* test()
   {
       int a = 10;
       return &a;
   }
   
   int main()
   {
       int* p = test();
       *p = 20;
       return 0;
   }
   ```

**如何避免野指针？**

1. 指针初始化；
2. 小心指针越界；
3. 指针指向空间释放及时置NULL；
4. 指针使用之前检查有效性，检查方法是： `if (p != NULL)`

## 3. 指针运算

1. 指针 +/- 整数
2. 指针 - 指针  （得到的是两个指针之间的元素个数，前提是两个指针指向同一块空间）
3. 指针的关系运算（指针比较大小）

**用指针相减实现求字符串长度的函数：**

```c
int my_strlen(char* str)
{
    char* start = str;
    while (*str != '\0')
    {
        str ++;
    }
    
    return str - start;
}
```

## 4. 编译器怎么编译

先看一段代码：

```c
int arr[10] = {1, 2, 3, 4};
printf("%d %d\n", arr[2], 2[arr]);
```

打印出来的是：

> 3 3

这是因为实质上，`[]` 是一个操作符，编译器在处理  `arr[2]`  时，会当做 `*(arr + 2)` 来处理，而如果写成 `2[arr]` ,编译器会当成 `*(2+arr)` 来处理；

如果在上述代码中，再令 `int *p = arr;` ，那么也可以用 `p[2]` 或者 `2[p]` 来访问数组的第二个元素，因为编译器会当成 `*(p+2)` 和 `*(2+p)` 来处理。 

## 5. 指针数组

本质上是数组，数组里面的元素都是指针。

```c
int* parr[5];  // 指针数组的声明，数组元素指向整形
char* pch[5];  // 指针数组的声明，数组元素指向字符
/* 最好进行初始化，这里先不介绍 */
```









































