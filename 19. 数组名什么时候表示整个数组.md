## 数组名什么时候是首元素地址，什么时候表示整个数组？

### 1. 理论

**一般情况下，数组名与数组的首地址是一样的，但也有例外**：

- sizeof(数组名)  此时数组名指的是整个数组，sizeof(数组名) 计算的是整个数组的大小，单位是字节；
- &数组名，数组名代表的是整个数组，取出的地址是整个数组的地址

### 2. 实践验证

```c
int a[3][4] = {0};
```

如果如上述定义了数组a，那么：

> sizeof(a) 就是 48；
>
> **sizeof(a[0]) 就是16**，因为，a是一个3行4列的二维数组，而 `a[0]` 是第一行数组的**数组名**，因此 `sizeof(a[0])` 这时表示的第一行元素组成的数组所占字节的大小；
> **sizeof(a[0]+1) 是4/8**，这里a[0]是第一行数组的数组名，代表的是第一行数组首元素的地址，所以 `a[0]+1` 代表的是第一行的第二个元素的地址；如果是32位平台，结果是4，如果是64位平台，结果是8；
>
> sizeof(a+1) 也是一样的道理，是4/8，这里 `a` 代表的是第一行数组的地址， `a+1` 是第二行数组的地址；
>
> sizeof(*(a[0]+1)) 是 4, `*(a[0]+1)` 表示的是第一行的第二个元素，int型，占4个字节；
>
> sizeof(*(a+1)) 是16，因为 `a+1` 是第二行数组的地址，对其解引用，得到的就是第二行数组，计算的就是第二行数组的大小；
>
> sizeof(&a[0]+1) 是 4/8，因为a[0]是第一行数组的数组名，&数组名取出的是第一行整个数组的地址，`&a[0]+1` 表示的是第二行整个数组的地址；
>
> sizeof(*(&a[0]+1)) 是16，`*(&a[0]+1)` 表示的是第二行数组；

### 3.实践收获

1. `*(a[0]+1)` 和 `a[0][1]` 是等价的；

2. `*(a+1)` 和 `a[1]` 也是等价的；
3. `a+1` 和 `&a[0]+1` 也是等价的；

### 4. 题目

下面代码的返回是什么？

```c
int main()
{
    int a[5] = {1, 2, 3, 4, 5};
    int *ptr = (int *)(&a + 1);
    printf("%d %d\n", *(a+1), *(ptr - 1));
    return 0;
}
```

> 2 5

