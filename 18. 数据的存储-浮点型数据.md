## 以32位浮点数为例介绍浮点数的存储

任意一个二进制浮点数V可以表示成下面的形式：

>(-1)^s * M * 2^E
>
>(-1)^s表示符号位，当s=0时，V为正数；当s=1，V为负数
>
>M表示有效数字，1<=M<2
>
>2^E 表示指数位

**举个栗子：**

10进制的5.5 转换成二进制是101.1 ,转换过程如下:
$$
5.5 = 1*2^2 + 0*2^1+1*2^0+1*2^{-1}
$$
还可以进行如下转换：
$$
101.1\rightarrow 1.011*2^2 \rightarrow (-1)^0*1.011*2^2
$$
与IEEE 754标准进行比较，就有：s=0, M=1.011, E=2

**IEEE 754规定**：对于32位浮点数，最高的一位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。

**IEEE 754 对有效数字M和指数E，还有一些特别规定。** 因为 $1<=M<2$ ,所以M可以写成1.xxx的形式，其中xxx表示小数部分。

IEEE 754规定，**在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去**，只保存后面xxx的部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，时节省1位有效数字。以32位浮点数为例，留给M的只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。

**至于指数E，情况就比较复杂**

首先，E为一个无符号整数，这意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047.但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。

所以，对于5.5，存到内存中就是：

2+127 = 129 = 10000001

```c
0100 0000 1011 0000 0000 0000 0000 0000
40 b0 00 00 
```

**指数E从内存中取出还可以再分成三种情况:**
**E不全为0或不全为1**

> 这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再
> 将有效数字M前加上第一位的1。比如：0.5（1/2）的二进制形式为0.1，由于规定正数部分必须
> 为1，即将小数点右移1位，则为1.0*2^(-1），其阶码为-1+127=126，表示为01111110，而尾数
> 1.0去掉整数部分为0，补齐0到23位 00000000000000000000000，则其二进制表示形式为：

```c
0 01111110 00000000000000000000000
```

**E全为0**

> 这时，浮点数的指数E等于1-127（或者1-1023）即为真实值，有效数字M不再加上第一位的1，
> 而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。

**E全为1**

> 这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）