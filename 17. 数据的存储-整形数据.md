# 数据的存储

## 1. 一些基础知识

1. 局部变量是放在栈区上的；
2. **栈区的使用习惯是先使用高地址，再使用低地址；**
3. 数组随着下标的增长，地址是由低到高变化的；

## 2. 整形在内存中的存储

整数的二进制表示有三种形式，分别是**原码、反码、补码**，整数在内存中存储的是二进制的补码。

补码和原码互相转换，都可以按取反加1来转，其运算过程是相同的，不需要额外的硬件电路。

## 3. 大端、小端字节序

**题目1：请简述大端字节序与小端字节序的概念，设计一个小程序来判断当前机器的字节序**

> **大端**字节序：把数据的低位字节序的内容存放在高地址处，高位字节序的内容存放在低地址处；
>
> **小端**字节序：把数据的低位字节序的内容存放在低地址处，高位字节序的内容存放在高地址处；

```c
int main()
{
    int num     =   0x11110000;
    short* p    =   (short*) &num;
    if (*p == 0)   // 低位字节序存在低地址
        printf("小端字节序\n");
    else
        printf("大端字节序\n");
    return 0;
}
```

**题目2：下面代码打印出的结果是什么？**

```c
char          a = -1;  // 11111111
signed char   b = -1;  // 11111111
unsigned char c = -1;  // 11111111
printf("a=%d b=%d c=%d\n", a, b, c);
```

> a=-1 b=-1 c=255

解析：

-1的32位补码是 11111111111111111111111111111111

但是char、signed char 、unsigned char 都只能放8个比特位，**高位被舍弃，存放的数据都是一样的，都是最后8个1**，即 11111111；

不同的是，各种变量类型对 11111111 的理解方式是不一样的：char 和 signed char 都认为在 11111111 中最高的那一位是符号位，但是unsigned char 不那么认为。

整形提升发生在打印时，**怎么提升取决于其类型**，a 和 b 都是char类型，整形提升时高位补1，打印出的结果是 -1. 但是 c 在整形提升时，**因为其类型是无符号的，高位补的全是 0** ，打印的结果就变成了 255.

**题目3：下面的代码打印出的结果是什么？**

```c
char          a = -128;
printf("%u\n", a);  // u%表示无符号十进制整数
printf("%d\n", a);  // d%表示有符号十进制整数
```

>  4294967168
>
> -128

解析：

-128:  10000000 00000000 00000000 10000000 原码

-128:  11111111 11111111 11111111 01111111 反码

-128:  11111111 11111111 11111111 10000000 补码

char a 被截断为：10000000

打印时，会进行整形提升，**怎么提升取决于其类型，因为char a 是有符号的，所以提升时前面全部补1**，提升为：

11111111 11111111 11111111 10000000

若是以无符号整形进行打印的，上述补码就是其原码，这样，得到结果：4294967168

若是以有符号整形进行打印的，上述补码对应的原码是：10000000 00000000 00000000 10000000，打印出来的结果是：-128

**题目4：下面的代码打印出的结果是什么？**

```c
char          a = -128;
printf("%u\n", a);  // u%表示无符号十进制整数
```

> 4294967168

## 4. 其他补充

1. char 类型是 signed char 还是 unsigned char，C语言的标准并没规定，取决于编译器；但是 C语言标准规定了 int 就是 signed int, short 就是 signed short；

2. unsigned int 和 int 型的数据相加，结果要用 unsigned int 来存储；

