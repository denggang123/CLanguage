## 1. 动态内存开辟的常见错误

1. 对空指针的解引用操作

​	要对 malloc 函数的返回值进行判断，如果是空指针，说明开辟失败，不应该再使用返回的地址。

2. 对动态开辟的空间越界访问

​	失误操作时可能会出现。

3. 使用free释放非动态开辟的空间

​	非动态开辟的内存空间一般是在栈区，无需释放。

4. 使用free释放一块动态开辟的内存的一部分

​	比如用指针p接收malloc函数的返回值时，又进行了一些 p++ 的操作，最后在某个位置使用 free(p) 语句，这是不合理的！

5. 对同一块动态内存多次释放

​	写代码时如果不记得某一块内存是否释放过一次，再次释放也会造成问题。所以释放完指向某一块动态开辟的指针ptr后，一定要对ptr进行置空！因为 If ptr is a *null pointer*, **free(ptr)** does nothing.

6. 动态开辟的空间忘记释放

​	比如在调用某个函数时，在这个函数内部动态开辟了一块内存，在这个函数内部如果没有对其进行释放的话，等函数调用完毕，可能会没有机会再释放了，因为指向这块动态开辟的内存空间的指针是存放在栈区的，调用完毕后，可能不会再有变量记得这个地址。如果该程序是一个服务器程序，7*24小时不间断运行，每次调用这样的函数都会丢失掉一块内存，内存迟早会被吃光，这就是**内存泄漏**问题！

## 2. 经典题目

**题目1：** 下面的代码能否输出 hello world?

```c
char *GetMemory(void)
{
  char p[] = "hello world";
  return p;
}
void Test(void)
{
  char *str = NULL;
  str = GetMemory();
  printf(str);
}

int main()
{
  Test();
  return 0;
}

//GetMemory 函数内部创建的数组是在栈区上创建的
//出了函数，p数组的空间就还给了操作系统
//返回的地址是没有实际的意义，如果通过返回的地址，去访问内存就是非法访问内存的
```

>  不能，因为 GetMemory 函数虽然返回出去了p的地址，但 hello world 字符串是存在栈区的，函数调用结束，hello world所占的这块空间已经还给操作系统！这种问题属于返回栈空间地址问题
